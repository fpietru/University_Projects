section .text
global _start

; Stałe dla wywołań systemowych i flag
O_RDWR      equ 2
PROT_READ   equ 1
PROT_WRITE  equ 2
MAP_SHARED  equ 1
MS_SYNC     equ 4

_start:
    ; Sprawdzenie liczby argumentów
    pop rcx                 ; rcx = argc
    cmp rcx, 2              ; oczekujemy dokładnie 2 argumenty (nazwa programu + plik)
    jne .error              ; jeśli nie, błąd

    ; Pobranie nazwy pliku z argumentów
    pop rdi                 ; argv[0] (nazwa programu)
    pop rdi                 ; argv[1] (nazwa pliku)

    ; Otwarcie pliku w trybie odczytu i zapisu
    mov rax, 2              ; sys_open
    mov rsi, O_RDWR         ; flagi: O_RDWR
    xor rdx, rdx            ; tryb dostępu: 0
    syscall
    test rax, rax           ; sprawdź, czy deskryptor jest ujemny (błąd)
    js .error               ; jeśli błąd, skocz do .error
    mov r12, rax            ; zapisz deskryptor pliku w r12

    ; Pobranie rozmiaru pliku za pomocą sys_fstat
    sub rsp, 144            ; rezerwacja miejsca na struct stat (144 bajty)
    mov rax, 5              ; sys_fstat
    mov rdi, r12            ; deskryptor pliku
    mov rsi, rsp            ; wskaźnik na struct stat
    syscall
    test rax, rax           ; sprawdź, czy zwrócono błąd (rax < 0)
    js .close_error         ; jeśli błąd, zamknij plik i zakończ
    mov r13, [rsp + 48]     ; odczytaj st_size (offset 48 w struct stat)
    add rsp, 144            ; przywróć wskaźnik stosu

    ; Sprawdzenie, czy plik jest mniejszy niż 2 bajty
    cmp r13, 2
    jl .close_file          ; jeśli tak, zamknij plik i zakończ

    ; Mapowanie pliku do pamięci
    mov rax, 9              ; sys_mmap
    xor rdi, rdi            ; addr = NULL (wybór systemu)
    mov rsi, r13            ; length = rozmiar pliku
    mov rdx, PROT_READ | PROT_WRITE ; prot: odczyt i zapis
    mov r10, MAP_SHARED     ; flags: MAP_SHARED
    mov r8, r12             ; fd: deskryptor pliku
    xor r9, r9              ; offset = 0
    syscall
    cmp rax, -1             ; sprawdź MAP_FAILED
    je .close_error         ; jeśli błąd, zamknij plik i zakończ
    mov r14, rax            ; zapisz adres mapowania w r14

    ; Odwracanie zawartości pliku w pamięci
    mov rdi, rax            ; wskaźnik na początek danych (rdi)
    lea rsi, [rax + r13 - 1] ; wskaźnik na koniec danych (rsi)
.reverse_loop:
    cmp rdi, rsi            ; porównaj wskaźniki
    jge .after_reverse      ; zakończ, gdy rdi >= rsi
    mov al, [rdi]           ; zamiana bajtów
    mov cl, [rsi]
    mov [rdi], cl
    mov [rsi], al
    inc rdi                 ; przesuń wskaźnik początku w prawo
    dec rsi                 ; przesuń wskaźnik końca w lewo
    jmp .reverse_loop

.after_reverse:
    ; Synchronizacja zmian z dyskiem
    mov rax, 26             ; sys_msync
    mov rdi, r14            ; adres mapowania
    mov rsi, r13            ; rozmiar
    mov rdx, MS_SYNC        ; flagi: MS_SYNC
    syscall
    test rax, rax           ; sprawdź błąd
    js .unmap_close_error   ; jeśli błąd, sprzątanie i zakończ

    ; Odmapowanie pliku z pamięci
    mov rax, 11             ; sys_munmap
    mov rdi, r14            ; adres mapowania
    mov rsi, r13            ; rozmiar
    syscall
    test rax, rax           ; sprawdź błąd
    js .close_error         ; jeśli błąd, zamknij plik i zakończ

.close_file:
    ; Zamknięcie pliku
    mov rax, 3              ; sys_close
    mov rdi, r12            ; deskryptor pliku
    syscall
    test rax, rax           ; sprawdź błąd
    js .error               ; jeśli błąd, zakończ z kodem 1

    ; Zakończenie programu z kodem 0 (sukces)
    xor rdi, rdi            ; kod wyjścia 0
    jmp .exit

.unmap_close_error:
    ; Odmapuj w przypadku błędu msync (ignoruj błędy)
    mov rax, 11             ; sys_munmap
    mov rdi, r14
    mov rsi, r13
    syscall

.close_error:
    ; Zamknięcie pliku po błędzie
    mov rax, 3              ; sys_close
    mov rdi, r12
    syscall

.error:
    ; Zakończenie programu z kodem 1 (błąd)
    mov rdi, 1

.exit:
    ; Wywołanie sys_exit
    mov rax, 60             ; sys_exit
    syscall